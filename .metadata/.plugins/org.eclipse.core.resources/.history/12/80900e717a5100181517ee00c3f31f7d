package controllers


import javax.inject._
import java.util.concurrent.atomic.AtomicInteger
import play.api.mvc._
import play.api.libs.json.Writes
import play.api.libs.json.Json
import play.api.libs.json.Reads
import play.api.libs.json.JsPath
import play.api.libs.json.Reads._
import play.api.libs.functional.syntax._
import java.util.concurrent.atomic.AtomicReference

import akka.actor.ActorSystem
import akka.stream.Materializer
import javax.inject.Inject
import play.api.libs.streams.ActorFlow
import play.api.mvc.AbstractController
import play.api.mvc.ControllerComponents
import play.api.mvc.WebSocket
import actors.WSChatActor
import actors.WSChatManager

import play.api.db.slick.DatabaseConfigProvider
import play.api.db.slick.HasDatabaseConfigProvider

import slick.jdbc.JdbcProfile
import slick.jdbc.JdbcCapabilities
import slick.jdbc.MySQLProfile.api._
import models.MeowderQueries
import scala.concurrent.ExecutionContext
import play.api.data.Form
import play.api.data.Forms.mapping
import play.api.data.Forms._
import scala.concurrent.Future
import Console._

class MeowderChatController @Inject() (
    protected val dbConfigProvider: DatabaseConfigProvider,
    mcc: MessagesControllerComponents) (implicit system: ActorSystem, mat: Materializer, ec: ExecutionContext) extends MessagesAbstractController(mcc) 
    with HasDatabaseConfigProvider[JdbcProfile] {
  
  
  val wsManager = system.actorOf(WSChatManager.props)
  
  def index = Action { implicit request =>
    Ok(views.html.datingChat())
  }
  
  def socket = WebSocket.accept[String, String] { request =>
    ActorFlow.actorRef { out =>
      WSChatActor.props(out, wsManager)
    }
  }
  
  
}